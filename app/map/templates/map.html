{% extends 'base.html' %}

{% block title %}Map{% endblock %}

{% block content %}
<style>
    #map {
        width: 100%;
        height: 600px;
    }
</style>

<h1>Dublin Cycling Map</h1>

<div class="d-flex justify-content-center mt-2">
    <select id="amenities-dropdown" class="form-select w-50" onchange="loadSelectedCategory()">
        <option value="">Select an amenity</option>
        <option value="parking_stands">Parking Stands</option>
        <option value="maintenance_stands">Maintenance Stands</option>
    </select>
</div>

<div id="map"></div>

<div class="d-flex justify-content-center mt-2">
    <button class="btn btn-primary" onclick="updateLocation()">Update Location</button>
</div>
{% endblock %}

{% block extra_js %}
<script>
    const MAP_CENTER = [53.3498, -6.2603];
    const MAP_ZOOM = 12;
    const API_BASE = '/api/';
    
    // Initialize map
    const map = L.map('map').setView(MAP_CENTER, MAP_ZOOM);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    // Layer groups for managing map layers
    const cyclewaysLayerGroup = L.layerGroup().addTo(map);
    const categoryLayerGroup = L.layerGroup().addTo(map);

    // Style for cycleways
    const cyclewayStyle = {
        color: '#3388ff',
        weight: 3,
        opacity: 0.7
    };

    // Create popup content dynamically
function createPopupContent(feature) {
    let popupContent = '';
    const props = feature.properties || {};

    // Structured fields with specific formatting
    if (props.featureID) {
        popupContent += `<strong>Feature ID:</strong> ${props.featureID}<br>`;
    }
    if (props.name) {
        popupContent += `<strong>Name:</strong> ${props.name !== 'undefined' ? props.name : 'No Name'}<br>`;
    }
    if (props.layer) {
        popupContent += `<strong>Layer:</strong> ${props.layer}<br>`;
    }
    if (props.colour) {
        popupContent += `<strong>Colour:</strong> ${props.colour}<br>`;
    }
    if (props.linetype) {
        popupContent += `<strong>Line Type:</strong> ${props.linetype}<br>`;
    }
    if (props.refname) {
        popupContent += `<strong>Reference Name:</strong> ${props.refname}<br>`;
    }
    if (props.description) {
        popupContent += `<strong>Description:</strong> ${props.description}<br>`;
    }
    if (props.twoway) {
        const twoway = props.twoway === '1' ? 'Yes' : 'No';
        popupContent += `<strong>Two Way:</strong> ${twoway}<br>`;
    }
    if (props.bollard_protected) {
        const bollardProtected = props.bollard_protected === '1' ? 'Yes' : 'No';
        popupContent += `<strong>Bollard Protected:</strong> ${bollardProtected}<br>`;
    }
    if (props.shape_length) {
        const shapeLengthKm = (parseFloat(props.shape_length) / 1000).toFixed(2);
        popupContent += `<strong>Lane Length:</strong> ${shapeLengthKm} km<br>`;
    }
	if (props.location) {
		popupContent += `<strong>Location:</strong> ${props.location}<br>`;
	}
	if (props.date_added) {
		popupContent += `<strong>Date Added:</strong> ${props.date_added}<br>`;
	}
	if (props.area) {
		popupContent += `<strong>Area:</strong> ${props.area}<br>`;
	}
	if (props.stand_type && props.stand_type.trim() !== '') {
		popupContent += `<strong>Stand Type:</strong> ${props.stand_type}<br>`;
	}
    // Dynamically render any other fields
    Object.entries(props).forEach(([key, value]) => {
        // Skip fields that are already handled above or unwanted
        if (![
            'featureID', 'name', 'layer', 'colour', 'linetype', 
            'refname', 'description', 'twoway', 'bollard_protected', 'shape_length',
			'featureID_internal', 'location', 'date_added', 'area', 'public_stands',
			'private_stands', 'stand_type', 'x', 'y'
        ].includes(key)) {
            popupContent += `<strong>${key}:</strong> ${value}<br>`;
        }
    });

    return popupContent;
}

    // Load GeoJSON data for a given endpoint
    async function loadGeoJSON(endpoint, layerGroup, style = null) {
        try {
            const response = await fetch(`${API_BASE}${endpoint}/`);
            if (!response.ok) throw new Error(`Failed to fetch ${endpoint}: ${response.statusText}`);
            const data = await response.json();
            layerGroup.clearLayers();
            L.geoJSON(data, {
                style: style || undefined,
                pointToLayer: (feature, latlng) => L.marker(latlng, { icon: createGreenMarkerIcon() }),
                onEachFeature: (feature, layer) => layer.bindPopup(createPopupContent(feature))
            }).addTo(layerGroup);
        } catch (error) {
            console.error(`Error loading ${endpoint}:`, error);
        }
    }

    // Load cycleways data
    function loadCycleways() {
        loadGeoJSON('cycleways', cyclewaysLayerGroup, cyclewayStyle);
    }

    // Load selected category from dropdown
    function loadSelectedCategory() {
        const selectedCategory = document.getElementById('amenities-dropdown').value;
        const endpoints = {
            parking_stands: 'parking-stands',
            maintenance_stands: 'maintenance-stands'
        };
        const endpoint = endpoints[selectedCategory];
        if (!endpoint) {
            categoryLayerGroup.clearLayers();
            return;
        }
        loadGeoJSON(endpoint, categoryLayerGroup);
    }

    // Update map with user's location
    async function updateLocation() {
        if (!navigator.geolocation) {
            console.error('Geolocation is not supported by this browser.');
            return;
        }

        navigator.geolocation.getCurrentPosition(async position => {
            const { latitude, longitude, accuracy } = position.coords;
            const marker = L.marker([latitude, longitude]).addTo(map);
            marker.bindPopup(`You are within ${accuracy} meters from this point`).openPopup();

            try {
                const csrfToken = '{{ csrf_token }}';
                const response = await fetch(`${API_BASE}location/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ latitude, longitude })
                });
                if (!response.ok) {
                    const data = await response.json();
                    throw new Error(data.error || 'Failed to update location');
                }
                console.log('Location updated successfully');
            } catch (error) {
                console.error('Error updating location:', error);
            }
        }, error => {
            console.error('Error fetching location:', error);
        });
    }

    // Create green marker icon
    function createGreenMarkerIcon() {
        return new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });
    }

    // On document load, initialize map with cycleways and user location
    document.addEventListener('DOMContentLoaded', () => {
        loadCycleways();
        updateLocation();
    });
</script>
{% endblock %}