{% extends 'base.html' %} {% block title %}Map{% endblock %} {% block content %} {% load static %}
<style>
	#map {
		width: 100%;
		position: relative;
		height: calc(100vh - 120px);
	}
	#dropdown-container {
		z-index: 1000;
		width: auto;
		max-height: fit-content;
		top: 10px;
		left: 10px;
		right: 10px;
		bottom: auto;
		border-radius: 5px;
	}
	#amenities-dropdown {
		background-color: rgba(255, 255, 255, 0.75);
		color: #333;
	}
	@media (max-width: 576px) {
		#dropdown-container {
			width: auto;
			max-height: fit-content;
			top: auto;
			left: 10px;
			right: auto;
			bottom: 10px;
			transform: none;
		}
		.leaflet-routing-container {
			display: none;
		}
	}
	#right-button-group {
		position: absolute;
		bottom: 10px;
		right: 10px;
		z-index: 1000;
	}
	.collapse-horizontal {
		transition: width 0.35s ease;
		overflow: hidden;
		opacity: 1;
	}
	#search-control.collapsing,
	#layer-control.collapsing {
		width: 0 !important;
		opacity: 0;
		transition: width 0.35s ease;
	}
	#search-control {
		position: absolute;
		bottom: 0px;
		right: 35px;
		z-index: 1000;
		padding: 10px;
		font-size: 14px;
		width: 275px;
	}
	#search-location {
		font-size: 16px;
	}
	.leaflet-control-attribution {
		display: none;
	}
	#left-button-group {
		position: absolute;
		bottom: 10px;
		left: 10px;
		z-index: 1000;
	}
	#legend {
		position: absolute;
		bottom: 0px;
		left: 40px;
		border-radius: 5px;
		padding: 10px;
		font-size: 14px;
		width: 275px;
	}
	#legend h5 {
		margin-top: 0;
		margin-bottom: 10px;
		font-size: 16px;
	}
	#layer-control {
		position: absolute;
		bottom: 0px;
		right: 35px;
		z-index: 1000;
		padding: 10px;
		font-size: 14px;
		width: 275px;
	}
	.collapse-horizontal,
	.collapsing,
	.show,
	.collapse,
	.card .card-body {
		z-index: 1000;
	}
	.collapse-horizontal {
		transition: width 0.35s ease; /* Smooth animation */
		overflow: hidden;
		opacity: 1; /* Start fully visible */
	}

	#legend.collapsing,
	#layer-control.collapsing {
		width: 0 !important;
		opacity: 0; /* Hide content smoothly */
		transition: width 0.35s ease;
	}
</style>

<h3 class="text-center pt-2">Dublin Cycling Map</h3>

<div id="map" class="position-relative">
	<div id="dropdown-container" class="position-absolute top-0 start-50 translate-middle-x mt-3">
		<select id="amenities-dropdown" class="form-select w-100" onchange="loadSelectedCategory()">
			<option value="default">Select an amenity</option>
			<option value="parking_stands">üÖøÔ∏è Parking Stands</option>
			<option value="maintenance_stands">üîß Maintenance Stands</option>
			<option value="dublin_bikes">üö≤ Dublin Bikes</option>
			<option value="bleeper_bikes">üö¥ Bleeper Bikes</option>
			<option value="moby_bikes">‚ö°Ô∏èüö≤ Moby Bikes</option>
		</select>
	</div>
	<div id="left-button-group" class="btn-group-vertical">
		<button
			id="update-location-button"
			class="bi bi-crosshair btn btn-light mb-2"
			onclick="fetchAndUpdateLocation()"
		></button>
		<button
			id="info-button"
			class="bi bi-info-circle btn btn-light"
			type="button"
			data-bs-toggle="collapse"
			data-bs-target="#legend"
			aria-expanded="false"
			aria-controls="legend"
		></button>
	</div>
	<button
		id="layer-button"
		class="bi bi-layers btn btn-light"
		type="button"
		data-bs-toggle="collapse"
		data-bs-target="#layer-control"
		aria-expanded="false"
		aria-controls="layer-control"
	></button>
	<!-- Collapsible Legend -->
	<div id="legend" class="collapse collapse-horizontal">
		<div class="card card-body" style="width: 250px; background-color: rgba(255, 255, 255, 0.8)">
			<h5>Map Legend</h5>
			<p><span style="color: #3388ff">‚óè</span> Segregated Cycling Infrastructure</p>
			<p><span style="color: #26ad24">‚óè</span> Parking & Maintenance Stands</p>
			<p><span style="color: #cb852c">‚óè</span> Cycling Services - Live API data</p>
		</div>
	</div>
	<div id="right-button-group" class="btn-group-vertical">
		<!-- Search Button -->
		<button
			id="search-button"
			class="bi bi-search btn btn-light mb-2"
			type="button"
			data-bs-toggle="collapse"
			data-bs-target="#search-control"
			aria-expanded="false"
			aria-controls="search-control"
		></button>

		<!-- Layer Control Button -->
		<button
			id="layer-button"
			class="bi bi-layers btn btn-light"
			type="button"
			data-bs-toggle="collapse"
			data-bs-target="#layer-control"
			aria-expanded="false"
			aria-controls="layer-control"
		></button>
	</div>

	<!-- Collapsible Search Card -->
	<div id="search-control" class="collapse collapse-horizontal">
		<div class="card card-body" style="width: 250px; background-color: rgba(255, 255, 255, 0.8)">
			<h5 class="end-0">Search</h5>
			<div class="form-floating mb-1">
				<input
					type="text"
					id="search-location"
					class="form-control form-control-sm"
					placeholder="Enter location"
				/>
				<label for="search-location">Enter location</label>
			</div>
			<button id="search-submit" class="btn btn-outline-primary btn-sm w-100" onclick="handleSearchAndRoute()">
				Search
			</button>
		</div>
	</div>

	<!-- Collapsible Layer Control Card -->
	<div id="layer-control" class="collapse collapse-horizontal">
		<div class="card card-body" style="width: 250px; background-color: rgba(255, 255, 255, 0.8)">
			<h5 class="end-0">Map Layers</h5>
			<form>
				<div class="form-check">
					<input class="form-check-input" type="checkbox" value="" id="cyclewaysLayer" checked />
					<label class="form-check-label" for="cyclewaysLayer"> üîµ Segregated Cycleways </label>
				</div>
				<div class="form-check">
					<input class="form-check-input" type="checkbox" value="" id="yellowInfrastructureLayer" />
					<label class="form-check-label" for="yellowInfrastructureLayer"> üü° Shared Cycleways </label>
				</div>
				<div class="form-check">
					<input class="form-check-input" type="checkbox" value="" id="redInfrastructureLayer" />
					<label class="form-check-label" for="redInfrastructureLayer"> üî¥ No Cycleways </label>
				</div>
			</form>
		</div>
	</div>
</div>

{% endblock %} {% block extra_js %}
<script>
	const MAP_CENTER = [53.3498, -6.2603];
	const MAP_ZOOM = 14;
	const API_BASE = '/api/';
	const MAPBOX_API_KEY = '{{ MAPBOX_API_KEY }}';
	let userLocation = null;
	let routeControl = null;

	// Initialize map
	const map = L.map('map').setView(MAP_CENTER, MAP_ZOOM);
	L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
		maxZoom: 19,
	}).addTo(map);

	// Layer groups for managing map layers
	const cyclewaysLayerGroup = L.layerGroup().addTo(map);
	const redInfrastructureLayerGroup = L.layerGroup().addTo(map);
	const yellowInfrastructureLayerGroup = L.layerGroup().addTo(map);
	const categoryLayerGroup = L.markerClusterGroup().addTo(map);

	// Styles for infrastructure
	const cyclewayStyle = { color: '#3388ff', weight: 4, opacity: 0.8 };
	const redInfrastructureStyle = { color: 'red', weight: 3, opacity: 0.8 };
	const yellowInfrastructureStyle = { color: '#ffd003', weight: 3, opacity: 0.9 };

	// Create popup content dynamically
	function createPopupContent(feature, markerCoords) {
		const props = feature.properties || {};
		const fields = [
			{ key: 'featureID', label: 'Feature ID' },
			{ key: 'name', label: 'Name', formatter: (v) => (v !== 'undefined' ? v : 'No Name') },
			{ key: 'layer', label: 'Layer' },
			{ key: 'colour', label: 'Colour' },
			{ key: 'linetype', label: 'Line Type' },
			{ key: 'refname', label: 'Reference Name' },
			{ key: 'description', label: 'Description' },
			{ key: 'twoway', label: 'Two Way', formatter: (v) => (v === '1' ? 'Yes' : 'No') },
			{ key: 'bollard_protected', label: 'Bollard Protected', formatter: (v) => (v === '1' ? 'Yes' : 'No') },
			{ key: 'shape_length', label: 'Lane Length', formatter: (v) => `${(parseFloat(v) / 1000).toFixed(2)} km` },
			{ key: 'location', label: 'Location' },
			{ key: 'date_added', label: 'Date Added' },
			{ key: 'area', label: 'Area' },
			{ key: 'stand_type', label: 'Stand Type' },
			{ key: 'bicycle_parking', label: 'Bicycle Parking Type' },
			{ key: 'covered', label: 'Is Sheltered?' },
			{ key: 'capacity', label: 'Bicycle Capacity' },
		];

		// Add structured fields
		let popupContent = fields
			.filter(({ key }) => props[key])
			.map(
				({ key, label, formatter }) =>
					`<strong>${label}:</strong> ${formatter ? formatter(props[key]) : props[key]}<br>`
			)
			.join('');

		// Add any other dynamic fields
		const excludedKeys = fields
			.map((f) => f.key)
			.concat(['featureID_internal', 'x', 'y', 'public_stands', 'private_stands', 'osm_id']);
		Object.entries(props).forEach(([key, value]) => {
			if (!excludedKeys.includes(key) && value && value.toString().trim()) {
				popupContent += `<strong>${key}:</strong> ${value}<br>`;
			}
		});

		// Add a button for routing only if the feature is a point
		if (feature.geometry.type === 'Point') {
			popupContent += `
				<div class="text-center mt-2">
					<button 
						class="btn btn-sm btn-outline-primary bi bi-arrow-up-circle"
						onclick="startRoutingFromPopup([${markerCoords.join(',')}])">
						Route Here
					</button>
				</div>`;
		}

		return popupContent;
	}

	// Load GeoJSON data with Routing on Click
	async function loadGeoJSON(endpoint, layerGroup, style = null) {
		try {
			const response = await fetch(`${API_BASE}${endpoint}/`);
			if (!response.ok) throw new Error(`Failed to fetch ${endpoint}: ${response.statusText}`);
			const data = await response.json();
			layerGroup.clearLayers();

			L.geoJSON(data, {
				style: style || undefined,
				pointToLayer: (feature, latlng) => {
					// Apply custom marker styling
					const iconStyle = createMarkerIcon(style || 'default');
					return L.marker(latlng, { icon: iconStyle });
				},
				onEachFeature: (feature, layer) => {
					const { coordinates } = feature.geometry;
					const markerCoords = [coordinates[1], coordinates[0]]; // [lat, lng]
					const popupContent = createPopupContent(feature, markerCoords); // Create popup content
					layer.bindPopup(popupContent); // Bind popup with route button
				},
			}).addTo(layerGroup);
		} catch (error) {
			console.error(`Error loading ${endpoint}:`, error);
		}
	}

	// Load cycleways and infrastructure
	async function loadCycleways() {
		await loadGeoJSON('cycleways', cyclewaysLayerGroup, cyclewayStyle);
	}
	async function loadRedInfrastructure() {
		await loadGeoJSON('red-cycling-infrastructure', redInfrastructureLayerGroup, redInfrastructureStyle);
	}
	async function loadYellowInfrastructure() {
		await loadGeoJSON('yellow-cycling-infrastructure', yellowInfrastructureLayerGroup, yellowInfrastructureStyle);
	}

	// Dropdown event handler
	async function loadSelectedCategory() {
		const selectedCategory = document.getElementById('amenities-dropdown').value;
		const endpoints = {
			parking_stands: 'parking-stands',
			maintenance_stands: 'maintenance-stands',
			dublin_bikes: 'dublin-bikes',
			bleeper_bikes: 'bleeper-bikes',
			moby_bikes: 'moby-bikes',
		};

		const endpoint = endpoints[selectedCategory];
		categoryLayerGroup.clearLayers();
		// Clear clusters if no selection
		if (!endpoint) {
			categoryLayerGroup.clearLayers();
			return;
		}

		// Define marker color
		const categoryStyle = ['dublin-bikes', 'bleeper-bikes', 'moby-bikes'].includes(endpoint) ? 'orange' : 'green';

		// Load the selected category with clustering
		await loadGeoJSON(endpoint, categoryLayerGroup, categoryStyle);
	}

	// Fetch and Update User Location
	async function fetchAndUpdateLocation() {
		return new Promise((resolve, reject) => {
			if (!navigator.geolocation) {
				console.error('Geolocation is not supported by this browser.');
				return reject('Geolocation is not supported.');
			}

			navigator.geolocation.getCurrentPosition(
				async (position) => {
					const { latitude, longitude, accuracy } = position.coords;
					userLocation = [latitude, longitude];

					// Update map with the user's location
					if (window.userLocationMarker) {
						map.removeLayer(window.userLocationMarker);
					}
					window.userLocationMarker = L.marker(userLocation).addTo(map);
					window.userLocationMarker
						.bindPopup(`You are within ${accuracy.toFixed(2)} meters from this point`)
						.openPopup();
					map.setView(userLocation, 14);

					// Optionally, send location to the server
					try {
						const csrfToken = document.querySelector('input#csrf-token').value || '{{ csrf_token }}';
						const response = await fetch(`${API_BASE}location/`, {
							method: 'POST',
							headers: {
								'Content-Type': 'application/json',
								'X-CSRFToken': csrfToken,
							},
							body: JSON.stringify({ latitude, longitude }),
						});
						if (!response.ok) {
							const data = await response.json();
							throw new Error(data.error || 'Failed to update location');
						}
						console.log('Location updated successfully on the server.');
					} catch (error) {
						console.error('Error updating location on the server:', error);
					}

					resolve(userLocation);
				},
				(error) => {
					console.error('Error fetching location:', error.message);
					reject(error.message);
				}
			);
		});
	}

	// Initialize Routing Control
	function initializeRoutingControl(startCoords, endCoords, mode = 'cycling') {
		if (routeControl) map.removeControl(routeControl);

		const profile = mode === 'walking' ? 'mapbox/walking' : 'mapbox/cycling';

		routeControl = L.Routing.control({
			waypoints: [L.latLng(...startCoords), L.latLng(...endCoords)],
			router: L.Routing.mapbox(MAPBOX_API_KEY, { profile }), // Specify mode of transportation
			lineOptions: { styles: [{ color: 'red', opacity: 0.5, weight: 3 }] },
		}).addTo(map);
	}

	// Geocode Location
	async function geocodeLocation(query) {
		const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(
			query
		)}.json?access_token=${MAPBOX_API_KEY}`;
		try {
			const response = await fetch(url);
			if (!response.ok) throw new Error('Failed to fetch location.');
			const data = await response.json();
			if (data.features && data.features.length) {
				const [lng, lat] = data.features[0].geometry.coordinates;
				return [lat, lng];
			}
			throw new Error('No results found.');
		} catch (error) {
			console.error(error.message);
			return null;
		}
	}

	// Handle Route Planning
	async function handleSearchAndRoute() {
		const endLocationQuery = document.getElementById('search-location').value;
		if (!endLocationQuery) return alert('Please enter a destination.');

		try {
			if (!userLocation) userLocation = await fetchAndUpdateLocation();
			const endCoords = await geocodeLocation(endLocationQuery);
			if (!endCoords) return alert('Unable to find the destination.');

			initializeRoutingControl(userLocation, endCoords);
		} catch (error) {
			console.error(error);
			alert('An error occurred while planning the route.');
		}
	}

	function startRoutingFromPopup(markerCoords) {
		if (!userLocation) {
			alert('User location is not available. Please enable location services.');
			return;
		}
		initializeRoutingControl(userLocation, markerCoords);
	}

	// Create marker icon with specified color - Green or Orange
	function createMarkerIcon(colour) {
		const iconUrl = `{% static 'img/marker-icon-2x-' %}${colour}.png`;
		return new L.Icon({
			iconUrl: iconUrl,
			shadowUrl: "{% static 'img/marker-shadow.png' %}",
			iconSize: [19, 31],
			iconAnchor: [9, 31],
			popupAnchor: [0.75, -25.5],
			shadowSize: [31, 31],
		});
	}

	// Add service worker registration and check for storage quota
	async function registerServiceWorker() {
		if ('serviceWorker' in navigator) {
			navigator.serviceWorker
				.register('{% static "serviceworker.js" %}', { scope: '/' })
				.then((registration) => {
					console.log('Service Worker registered with scope:', registration.scope);
				})
				.catch((error) => {
					console.error('Service Worker registration failed:', error);
				});
		}
		if ('storage' in navigator && 'persist' in navigator.storage) {
			navigator.storage.persist().then((granted) => {
				if (granted) {
					console.log('Persistent storage granted.');
				} else {
					console.warn('Persistent storage not granted. Cache may be cleared by the browser.');
				}
			});
		}
	}

	// On document load, initialize map with cycleways, user location and service worker
	document.addEventListener('DOMContentLoaded', async () => {
		// Initialize Segregated Cycleways (always loaded)
		await loadCycleways();
		userLocation = await fetchAndUpdateLocation();
		await registerServiceWorker();
		// Layer visibility control
		const cyclewaysCheckbox = document.getElementById('cyclewaysLayer');
		const redCheckbox = document.getElementById('redInfrastructureLayer');
		const yellowCheckbox = document.getElementById('yellowInfrastructureLayer');

		// Flags to track if data is already loaded
		let redInfrastructureLoaded = false;
		let yellowInfrastructureLoaded = false;

		// Event listeners for toggling layers
		cyclewaysCheckbox.addEventListener('change', () => {
			if (cyclewaysCheckbox.checked) {
				map.addLayer(cyclewaysLayerGroup);
			} else {
				map.removeLayer(cyclewaysLayerGroup);
			}
		});

		redCheckbox.addEventListener('change', async () => {
			if (redCheckbox.checked) {
				if (!redInfrastructureLoaded) {
					await loadRedInfrastructure();
					redInfrastructureLoaded = true;
				}
				map.addLayer(redInfrastructureLayerGroup);
			} else {
				map.removeLayer(redInfrastructureLayerGroup);
			}
		});

		yellowCheckbox.addEventListener('change', async () => {
			if (yellowCheckbox.checked) {
				if (!yellowInfrastructureLoaded) {
					await loadYellowInfrastructure();
					yellowInfrastructureLoaded = true;
				}
				map.addLayer(yellowInfrastructureLayerGroup);
			} else {
				map.removeLayer(yellowInfrastructureLayerGroup);
			}
		});
	});
</script>
{% endblock %}
