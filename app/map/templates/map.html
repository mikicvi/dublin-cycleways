{% extends 'base.html' %} {% block title %}Map{% endblock %} {% block content %} {% load static %}
<style>
	#map {
		width: 100%;
		position: relative;
		height: calc(100vh - 120px);
	}
	#dropdown-container {
		z-index: 1000;
		width: auto;
		max-height: fit-content;
		top: 10px;
		left: 10px;
		right: 10px;
		bottom: auto;
		border-radius: 5px;
	}
	#amenities-dropdown {
		background-color: rgba(255, 255, 255, 0.75);
		color: #333;
	}
	@media (max-width: 576px) {
		#dropdown-container {
			width: auto;
			max-height: fit-content;
			top: auto;
			left: 10px;
			right: auto;
			bottom: 10px;
			transform: none;
		}
	}
	#button-group {
		position: absolute;
		bottom: 10px;
		left: 10px;
		z-index: 1000;
	}
	.leaflet-control-attribution {
		display: none;
	}
	#legend {
		position: absolute;
		bottom: 0px;
		left: 40px;
		border-radius: 5px;
		padding: 10px;
		font-size: 14px;
		width: 275px;
	}
	#legend h5 {
		margin-top: 0;
		margin-bottom: 10px;
		font-size: 16px;
	}
	#layer-control {
		position: absolute;
		bottom: 0px;
		right: 35px;
		z-index: 1000;
		padding: 10px;
		font-size: 14px;
		width: 275px;
	}

	#layer-button {
		position: absolute;
		bottom: 10px;
		right: 10px;
		z-index: 1000;
		border-radius: 5px;
	}
	.collapse-horizontal,
	.collapsing,
	.show,
	.collapse,
	.card .card-body {
		z-index: 1000;
	}
	.collapse-horizontal {
		transition: width 0.35s ease; /* Smooth animation */
		overflow: hidden;
		opacity: 1; /* Start fully visible */
	}

	#legend.collapsing,
	#layer-control.collapsing {
		width: 0 !important;
		opacity: 0; /* Hide content smoothly */
		transition: width 0.35s ease;
	}
</style>

<h3 class="text-center pt-2">Dublin Safe Cycling Map</h3>

<div id="map" class="position-relative">
	<div id="dropdown-container" class="position-absolute top-0 start-50 translate-middle-x mt-3">
		<select id="amenities-dropdown" class="form-select w-100" onchange="loadSelectedCategory()">
			<option value="default">Select an amenity</option>
			<option value="parking_stands">üÖøÔ∏è Parking Stands</option>
			<option value="maintenance_stands">üîß Maintenance Stands</option>
			<option value="dublin_bikes">üö≤ Dublin Bikes</option>
		</select>
	</div>
	<div id="button-group" class="btn-group-vertical">
		<button
			id="update-location-button"
			class="bi bi-crosshair btn btn-light mb-2"
			onclick="updateLocation()"
		></button>
		<button
			id="info-button"
			class="bi bi-info-circle btn btn-light"
			type="button"
			data-bs-toggle="collapse"
			data-bs-target="#legend"
			aria-expanded="false"
			aria-controls="legend"
		></button>
	</div>
	<button
		id="layer-button"
		class="bi bi-layers btn btn-light"
		type="button"
		data-bs-toggle="collapse"
		data-bs-target="#layer-control"
		aria-expanded="false"
		aria-controls="layer-control"
	></button>
	<!-- Collapsible Legend -->
	<div id="legend" class="collapse collapse-horizontal">
		<div class="card card-body" style="width: 250px; background-color: rgba(255, 255, 255, 0.8)">
			<h5>Map Legend</h5>
			<p><span style="color: #3388ff">‚óè</span> Segregated Cycling Infrastructure</p>
			<p><span style="color: #26ad24">‚óè</span> Parking & Maintenance Stands</p>
			<p><span style="color: #cb852c">‚óè</span> Cycling Services - Live API data</p>
		</div>
	</div>
	<!-- Collapsible Layer Control -->
	<div id="layer-control" class="collapse collapse-horizontal">
		<div class="card card-body" style="width: 250px; background-color: rgba(255, 255, 255, 0.8)">
			<h5>Map Layers</h5>
			<form>
				<div class="form-check">
					<input class="form-check-input" type="checkbox" value="" id="cyclewaysLayer" checked />
					<label class="form-check-label" for="cyclewaysLayer"> üîµ Segregated Cycleways </label>
				</div>
				<div class="form-check">
					<input class="form-check-input" type="checkbox" value="" id="yellowInfrastructureLayer" />
					<label class="form-check-label" for="yellowInfrastructureLayer"> üü° Shared Cycleways </label>
				</div>
				<div class="form-check">
					<input class="form-check-input" type="checkbox" value="" id="redInfrastructureLayer" />
					<label class="form-check-label" for="redInfrastructureLayer"> üî¥ No Cycleways </label>
				</div>
			</form>
		</div>
	</div>
</div>

{% endblock %} {% block extra_js %}
<script>
	const MAP_CENTER = [53.3498, -6.2603];
	const MAP_ZOOM = 12;
	const API_BASE = '/api/';

	// Initialize map
	const map = L.map('map').setView(MAP_CENTER, MAP_ZOOM);
	L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
		maxZoom: 19,
	}).addTo(map);

	// Layer groups for managing map layers
	const cyclewaysLayerGroup = L.layerGroup().addTo(map);
	const redInfrastructureLayerGroup = L.layerGroup().addTo(map);
	const yellowInfrastructureLayerGroup = L.layerGroup().addTo(map);
	const categoryLayerGroup = L.markerClusterGroup().addTo(map);

	// Styles for infrastructure
	const cyclewayStyle = { color: '#3388ff', weight: 4, opacity: 0.8 };
	const redInfrastructureStyle = { color: 'red', weight: 3, opacity: 0.8 };
	const yellowInfrastructureStyle = { color: '#ffd003', weight: 3, opacity: 0.9 };

	// Create popup content dynamically
	function createPopupContent(feature) {
		const props = feature.properties || {};
		const fields = [
			{ key: 'featureID', label: 'Feature ID' },
			{ key: 'name', label: 'Name', formatter: (v) => (v !== 'undefined' ? v : 'No Name') },
			{ key: 'layer', label: 'Layer' },
			{ key: 'colour', label: 'Colour' },
			{ key: 'linetype', label: 'Line Type' },
			{ key: 'refname', label: 'Reference Name' },
			{ key: 'description', label: 'Description' },
			{ key: 'twoway', label: 'Two Way', formatter: (v) => (v === '1' ? 'Yes' : 'No') },
			{ key: 'bollard_protected', label: 'Bollard Protected', formatter: (v) => (v === '1' ? 'Yes' : 'No') },
			{ key: 'shape_length', label: 'Lane Length', formatter: (v) => `${(parseFloat(v) / 1000).toFixed(2)} km` },
			{ key: 'location', label: 'Location' },
			{ key: 'date_added', label: 'Date Added' },
			{ key: 'area', label: 'Area' },
			{ key: 'stand_type', label: 'Stand Type' },
			{ key: 'bicycle_parking', label: 'Bicycle Parking Type' },
			{ key: 'covered', label: 'Is Sheltered?' },
			{ key: 'capacity', label: 'Bicycle Capacity' },
		];

		// Add structured fields
		let popupContent = fields
			.filter(({ key }) => props[key])
			.map(
				({ key, label, formatter }) =>
					`<strong>${label}:</strong> ${formatter ? formatter(props[key]) : props[key]}<br>`
			)
			.join('');

		// Add any other dynamic fields
		const excludedKeys = fields
			.map((f) => f.key)
			.concat(['featureID_internal', 'x', 'y', 'public_stands', 'private_stands', 'osm_id']);
		Object.entries(props).forEach(([key, value]) => {
			if (!excludedKeys.includes(key) && value && value.toString().trim()) {
				popupContent += `<strong>${key}:</strong> ${value}<br>`;
			}
		});

		return popupContent;
	}

	// Load GeoJSON data for a given endpoint
	async function loadGeoJSON(endpoint, layerGroup, style = null) {
		try {
			const response = await fetch(`${API_BASE}${endpoint}/`);
			if (!response.ok) throw new Error(`Failed to fetch ${endpoint}: ${response.statusText}`);
			const data = await response.json();
			layerGroup.clearLayers();

			L.geoJSON(data, {
				style: style || undefined,
				pointToLayer: (feature, latlng) => L.marker(latlng, { icon: createMarkerIcon(style) }),
				onEachFeature: (feature, layer) => layer.bindPopup(createPopupContent(feature)),
			}).addTo(layerGroup);
		} catch (error) {
			console.error(`Error loading ${endpoint}:`, error);
		}
	}

	// Load cycleways and infrastructure
	async function loadCycleways() {
		await loadGeoJSON('cycleways', cyclewaysLayerGroup, cyclewayStyle);
	}
	async function loadRedInfrastructure() {
		await loadGeoJSON('red-cycling-infrastructure', redInfrastructureLayerGroup, redInfrastructureStyle);
	}
	async function loadYellowInfrastructure() {
		await loadGeoJSON('yellow-cycling-infrastructure', yellowInfrastructureLayerGroup, yellowInfrastructureStyle);
	}

	// Dropdown event handler
	async function loadSelectedCategory() {
		const selectedCategory = document.getElementById('amenities-dropdown').value;
		const endpoints = {
			parking_stands: 'parking-stands',
			maintenance_stands: 'maintenance-stands',
			dublin_bikes: 'dublin-bikes',
		};

		const endpoint = endpoints[selectedCategory];
		categoryLayerGroup.clearLayers();
		// Clear clusters if no selection
		if (!endpoint) {
			markerClusterGroup.clearLayers();
			return;
		}

		// Define marker color
		const categoryStyle = endpoint === 'dublin-bikes' ? 'orange' : 'green';

		// Load the selected category with clustering
		await loadGeoJSON(endpoint, categoryLayerGroup, categoryStyle);
	}

	// Update map with user's location
	async function updateLocation() {
		if (!navigator.geolocation) {
			console.error('Geolocation is not supported by this browser.');
			return;
		}

		navigator.geolocation.getCurrentPosition(
			async (position) => {
				const { latitude, longitude, accuracy } = position.coords;
				const marker = L.marker([latitude, longitude]).addTo(map);
				marker.bindPopup(`You are within ${accuracy} meters from this point`).openPopup();

				// Center map on user's location and zoom in
				map.setView([latitude, longitude], 14);

				try {
					const csrfToken = '{{ csrf_token }}';
					const response = await fetch(`${API_BASE}location/`, {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
							'X-CSRFToken': csrfToken,
						},
						body: JSON.stringify({ latitude, longitude }),
					});
					if (!response.ok) {
						const data = await response.json();
						throw new Error(data.error || 'Failed to update location');
					}
					console.log('Location updated successfully');
				} catch (error) {
					console.error('Error updating location:', error);
				}
			},
			(error) => {
				console.error('Error fetching location:', error);
			}
		);
	}

	// Create marker icon with specified color - Green or Orange
	function createMarkerIcon(colour) {
		const iconUrl = `{% static 'img/marker-icon-2x-' %}${colour}.png`;
		return new L.Icon({
			iconUrl: iconUrl,
			shadowUrl: "{% static 'img/marker-shadow.png' %}",
			iconSize: [19, 31],
			iconAnchor: [9, 31],
			popupAnchor: [0.75, -25.5],
			shadowSize: [31, 31],
		});
	}

	// Add service worker registration and check for storage quota
	async function registerServiceWorker() {
		if ('serviceWorker' in navigator) {
			navigator.serviceWorker
				.register('{% static "serviceworker.js" %}', { scope: '/' })
				.then((registration) => {
					console.log('Service Worker registered with scope:', registration.scope);
				})
				.catch((error) => {
					console.error('Service Worker registration failed:', error);
				});
		}
		if ('storage' in navigator && 'persist' in navigator.storage) {
			navigator.storage.persist().then((granted) => {
				if (granted) {
					console.log('Persistent storage granted.');
				} else {
					console.warn('Persistent storage not granted. Cache may be cleared by the browser.');
				}
			});
		}
	}

	// On document load, initialize map with cycleways, user location and service worker
	document.addEventListener('DOMContentLoaded', async () => {
		// Initialize Segregated Cycleways (always loaded)
		await loadCycleways();
		await updateLocation();
		await registerServiceWorker();
		// Layer visibility control
		const cyclewaysCheckbox = document.getElementById('cyclewaysLayer');
		const redCheckbox = document.getElementById('redInfrastructureLayer');
		const yellowCheckbox = document.getElementById('yellowInfrastructureLayer');

		// Flags to track if data is already loaded
		let redInfrastructureLoaded = false;
		let yellowInfrastructureLoaded = false;

		// Event listeners for toggling layers
		cyclewaysCheckbox.addEventListener('change', () => {
			if (cyclewaysCheckbox.checked) {
				map.addLayer(cyclewaysLayerGroup);
			} else {
				map.removeLayer(cyclewaysLayerGroup);
			}
		});

		redCheckbox.addEventListener('change', async () => {
			if (redCheckbox.checked) {
				if (!redInfrastructureLoaded) {
					await loadRedInfrastructure();
					redInfrastructureLoaded = true;
				}
				map.addLayer(redInfrastructureLayerGroup);
			} else {
				map.removeLayer(redInfrastructureLayerGroup);
			}
		});

		yellowCheckbox.addEventListener('change', async () => {
			if (yellowCheckbox.checked) {
				if (!yellowInfrastructureLoaded) {
					await loadYellowInfrastructure();
					yellowInfrastructureLoaded = true;
				}
				map.addLayer(yellowInfrastructureLayerGroup);
			} else {
				map.removeLayer(yellowInfrastructureLayerGroup);
			}
		});
	});
</script>
{% endblock %}
