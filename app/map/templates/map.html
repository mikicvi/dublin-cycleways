{% extends 'base.html' %} {% block title %}Map{% endblock %} {% block content %} {% load static %}
<style>
	#map {
		width: 100%;
		position: relative;
		height: calc(100vh - 120px);
	}
	@media (max-width: 576px) {
		#map {
			height: calc(100vh - 120px);
			width: 100%;
		}
	}
	#dropdown-container {
		z-index: 1000; /* Ensure the dropdown is above the map tiles */
		width: auto;
		top: 10px;
		left: 10px;
		right: 10px;
		bottom: auto;
		border-radius: 5px;
	}
	#amenities-dropdown {
		background-color: rgba(255, 255, 255, 0.75);
		color: #333;
	}
	@media (max-width: 576px) {
		#dropdown-container {
			width: auto;
			top: auto;
			left: 10px;
			right: auto;
			bottom: 10px;
			transform: none;
		}
	}
	#button-group {
		position: absolute;
		bottom: 10px;
		left: 10px;
		z-index: 1000;
	}
	.leaflet-control-attribution {
		display: none;
	}
	#legend {
		position: absolute;
		bottom: 10px;
		left: 50px;
		background-color: rgba(255, 255, 255, 0.75);
		border: 1px solid #ddd;
		border-radius: 5px;
		padding: 10px;
		font-size: 14px;
		width: 275px;
	}
	#legend h5 {
		margin-top: 0;
		margin-bottom: 10px;
		font-size: 16px;
	}
	.collapse-horizontal,
	.collapsing,
	.show,
	.collapse {
		z-index: 1050 !important;
	}
</style>

<h3 class="text-center">Dublin Safe Cycling Map</h3>

<div id="map" class="position-relative">
	<div id="dropdown-container" class="position-absolute top-0 start-50 translate-middle-x mt-3">
		<select id="amenities-dropdown" class="form-select w-100" onchange="loadSelectedCategory()">
			<option value="">Select an amenity</option>
			<option value="parking_stands">üö≤ Parking Stands</option>
			<option value="maintenance_stands">üîß Maintenance Stands</option>
		</select>
	</div>
	<div id="button-group" class="btn-group-vertical">
		<button
			id="update-location-button"
			class="bi bi-crosshair btn btn-light mb-2"
			onclick="updateLocation()"
		></button>
		<button
			id="info-button"
			class="bi bi-info-circle btn btn-light"
			type="button"
			data-bs-toggle="collapse"
			data-bs-target="#legend"
			aria-expanded="false"
			aria-controls="legend"
		></button>
	</div>
	<!-- Collapsible Legend -->
	<div id="legend" class="collapse collapse-horizontal">
		<div class="card card-body" style="width: 250px; background-color: rgba(255, 255, 255, 0.8)">
			<h5>Map Legend</h5>
			<p><span style="color: #3388ff">‚óè</span> Segregated Cycling Infrastructure</p>
			<p><span style="color: green">‚óè</span> Parking & Maintenance Stands</p>
		</div>
	</div>
</div>

{% endblock %} {% block extra_js %}
<script>
	const MAP_CENTER = [53.3498, -6.2603];
	const MAP_ZOOM = 12;
	const API_BASE = '/api/';

	// Initialize map
	const map = L.map('map').setView(MAP_CENTER, MAP_ZOOM);
	L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
		maxZoom: 19,
	}).addTo(map);

	// Layer groups for managing map layers
	const cyclewaysLayerGroup = L.layerGroup().addTo(map);
	const categoryLayerGroup = L.layerGroup().addTo(map);

	// Style for cycleways
	const cyclewayStyle = {
		color: '#3388ff',
		weight: 3,
		opacity: 0.7,
	};

	// Create popup content dynamically
	function createPopupContent(feature) {
		let popupContent = '';
		const props = feature.properties || {};

		// Structured fields with specific formatting
		if (props.featureID) {
			popupContent += `<strong>Feature ID:</strong> ${props.featureID}<br>`;
		}
		if (props.name) {
			popupContent += `<strong>Name:</strong> ${props.name !== 'undefined' ? props.name : 'No Name'}<br>`;
		}
		if (props.layer) {
			popupContent += `<strong>Layer:</strong> ${props.layer}<br>`;
		}
		if (props.colour) {
			popupContent += `<strong>Colour:</strong> ${props.colour}<br>`;
		}
		if (props.linetype) {
			popupContent += `<strong>Line Type:</strong> ${props.linetype}<br>`;
		}
		if (props.refname) {
			popupContent += `<strong>Reference Name:</strong> ${props.refname}<br>`;
		}
		if (props.description) {
			popupContent += `<strong>Description:</strong> ${props.description}<br>`;
		}
		if (props.twoway) {
			const twoway = props.twoway === '1' ? 'Yes' : 'No';
			popupContent += `<strong>Two Way:</strong> ${twoway}<br>`;
		}
		if (props.bollard_protected) {
			const bollardProtected = props.bollard_protected === '1' ? 'Yes' : 'No';
			popupContent += `<strong>Bollard Protected:</strong> ${bollardProtected}<br>`;
		}
		if (props.shape_length) {
			const shapeLengthKm = (parseFloat(props.shape_length) / 1000).toFixed(2);
			popupContent += `<strong>Lane Length:</strong> ${shapeLengthKm} km<br>`;
		}
		if (props.location) {
			popupContent += `<strong>Location:</strong> ${props.location}<br>`;
		}
		if (props.date_added) {
			popupContent += `<strong>Date Added:</strong> ${props.date_added}<br>`;
		}
		if (props.area) {
			popupContent += `<strong>Area:</strong> ${props.area}<br>`;
		}
		if (props.stand_type && props.stand_type.trim() !== '') {
			popupContent += `<strong>Stand Type:</strong> ${props.stand_type}<br>`;
		}
		// Dynamically render any other fields
		Object.entries(props).forEach(([key, value]) => {
			// Skip fields that are already handled above or unwanted
			if (
				![
					'featureID',
					'name',
					'layer',
					'colour',
					'linetype',
					'refname',
					'description',
					'twoway',
					'bollard_protected',
					'shape_length',
					'featureID_internal',
					'location',
					'date_added',
					'area',
					'public_stands',
					'private_stands',
					'stand_type',
					'x',
					'y',
				].includes(key)
			) {
				popupContent += `<strong>${key}:</strong> ${value}<br>`;
			}
		});

		return popupContent;
	}

	// Load GeoJSON data for a given endpoint
	async function loadGeoJSON(endpoint, layerGroup, style = null) {
		try {
			const response = await fetch(`${API_BASE}${endpoint}/`);
			if (!response.ok) throw new Error(`Failed to fetch ${endpoint}: ${response.statusText}`);
			const data = await response.json();
			layerGroup.clearLayers();
			L.geoJSON(data, {
				style: style || undefined,
				pointToLayer: (feature, latlng) => L.marker(latlng, { icon: createGreenMarkerIcon() }),
				onEachFeature: (feature, layer) => layer.bindPopup(createPopupContent(feature)),
			}).addTo(layerGroup);
		} catch (error) {
			console.error(`Error loading ${endpoint}:`, error);
		}
	}

	// Load cycleways data
	async function loadCycleways() {
		await loadGeoJSON('cycleways', cyclewaysLayerGroup, cyclewayStyle);
	}

	// Load selected category from dropdown
	async function loadSelectedCategory() {
		const selectedCategory = document.getElementById('amenities-dropdown').value;
		const endpoints = {
			parking_stands: 'parking-stands',
			maintenance_stands: 'maintenance-stands',
		};
		const endpoint = endpoints[selectedCategory];
		if (!endpoint) {
			categoryLayerGroup.clearLayers();
			return;
		}
		await loadGeoJSON(endpoint, categoryLayerGroup);
	}

	// Update map with user's location
	async function updateLocation() {
		if (!navigator.geolocation) {
			console.error('Geolocation is not supported by this browser.');
			return;
		}

		navigator.geolocation.getCurrentPosition(
			async (position) => {
				const { latitude, longitude, accuracy } = position.coords;
				const marker = L.marker([latitude, longitude]).addTo(map);
				marker.bindPopup(`You are within ${accuracy} meters from this point`).openPopup();

				try {
					const csrfToken = '{{ csrf_token }}';
					const response = await fetch(`${API_BASE}location/`, {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
							'X-CSRFToken': csrfToken,
						},
						body: JSON.stringify({ latitude, longitude }),
					});
					if (!response.ok) {
						const data = await response.json();
						throw new Error(data.error || 'Failed to update location');
					}
					console.log('Location updated successfully');
				} catch (error) {
					console.error('Error updating location:', error);
				}
			},
			(error) => {
				console.error('Error fetching location:', error);
			}
		);
	}

	// Create green marker icon
	function createGreenMarkerIcon() {
		return new L.Icon({
			iconUrl: "{% static 'img/marker-icon-2x-green.png' %}",
			shadowUrl: "{% static 'img/marker-shadow.png' %}",
			iconSize: [25, 41],
			iconAnchor: [12, 41],
			popupAnchor: [1, -34],
			shadowSize: [41, 41],
		});
	}

	// Add service worker registration and check for storage quota
	async function registerServiceWorker() {
		if ('serviceWorker' in navigator) {
			navigator.serviceWorker
				.register('{% static "serviceworker.js" %}', { scope: '/' })
				.then((registration) => {
					console.log('Service Worker registered with scope:', registration.scope);
				})
				.catch((error) => {
					console.error('Service Worker registration failed:', error);
				});
		}
		if ('storage' in navigator && 'persist' in navigator.storage) {
			navigator.storage.persist().then((granted) => {
				if (granted) {
					console.log('Persistent storage granted.');
				} else {
					console.warn('Persistent storage not granted. Cache may be cleared by the browser.');
				}
			});
		}
	}

	// On document load, initialize map with cycleways and user location
	document.addEventListener('DOMContentLoaded', async () => {
		await loadCycleways();
		await updateLocation();
		await registerServiceWorker();
	});
</script>
{% endblock %}
